<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Museu Virtual WebXR</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            z-index: 100;
            pointer-events: none;
        }

        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: #1a73e8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 100;
            display: none;
            pointer-events: auto;
        }

        #vrButton:hover {
            background: #1557b0;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
        }

        .hotspot {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.9);
            border: 3px solid white;
            border-radius: 50%;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            transition: transform 0.2s;
            pointer-events: auto;
            z-index: 50;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .hotspot:hover {
            transform: scale(1.2);
            background: rgba(33, 150, 243, 1);
        }

        .info-panel {
            position: absolute;
            background: white;
            padding: 20px;
            padding-top: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 300px;
            pointer-events: auto;
            z-index: 100;
        }

        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #1976d2;
        }

        .info-panel p {
            margin: 0;
            color: #333;
            line-height: 1.5;
        }

        .info-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
        }

        .info-panel .close-btn:hover {
            background: #d32f2f;
        }
    </style>
</head>

<body>
    <button id="vrButton">Entrar em RV</button>
    <div id="controls">
        <strong>Controles:</strong><br>
        WASD / Setas: Mover<br>
        Mouse: Olhar ao redor<br>
        Shift: Correr<br>
        Clique nos √≠cones 'i' para informa√ß√µes
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"
        integrity="sha512-n8IpKWzDnBOcBhRlHirMZOUvEq2bLRMuJGjuVqbzUJwtTsgwOgK5aS0c1JA647XWYfqvXve8k3PtZdzpipFjgg=="
        crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.1/examples/js/controls/OrbitControls.js"
        integrity="sha256-+ncCNttOcMopCUa47Sn26Tg06ZC2SnWoi/XikKAhnSY=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-x3@0.0.10/dist/x3-standalone.js"
        integrity="sha256-oKQUM+QPtvuvLmxpqxdxbrJAq21SZ+7hYK8WlGztXNE=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.0/examples/js/objects/Sky.js"></script>
    <script>

        let scene, camera, renderer, floor;
        let moveForward = false, moveBackward = false;
        let moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let isRunning = false;
        let interactiveObjects = [];
        let mouseX = 0, mouseY = 0;
        let targetRotationY = 0, targetRotationX = 0;
        let currentRotationY = 0, currentRotationX = 0;
        let cameraHolder;
        let walls = [];
        let obstacles = [];
        const playerRadius = 0.5;
        const gltfLoader = new THREE.GLTFLoader();
        let x3;

        let cameraRotationEnabled = true;
        let isShiftPressed = false;
        const rotationSpeedNormal = 0.1;
        const rotationSpeedSlow = 0.03;
        let infoPanelOpen = false;

        let detailScene, detailCamera, detailRenderer;
        let isInDetailView = false;
        let currentDetailObject = null;

        let isPanoramaMode = false;
        let currentPanoramaScene = null;
        let panoramaEnvironments = {
            'kennedy': {
                name: 'Centro Espacial Kennedy',
                image: './images/kennedy-panorama.jpg',
                position: { x: 0, y: 1.6, z: 0 },
                useEmbedding: true,
                embedUrl: 'https://www.google.com/maps/embed?pb=!4v1762740838344!6m8!1m7!1s6wyy-8WY3mlVknnlPsFV3A!2m2!1d28.60532695948118!2d-80.66950944302398!3f0.5495593664942362!4f4.101836796878231!5f0.7820865974627469'
            },
            'iss-lab': {
                name: 'Laborat√≥rio ISS',
                image: './images/iss-lab-panorama.jpg',
                position: { x: 0, y: 1.6, z: 0 }
            },
            'launch-pad': {
                name: 'Plataforma de Lan√ßamento',
                image: './images/launch-pad-panorama.jpg',
                position: { x: 0, y: 1.6, z: 0 }
            }
        };

        function createPanoramaScene(environmentKey) {
            const env = panoramaEnvironments[environmentKey];
            if (!env) return;

            if (env.useEmbedding) {
                createEmbeddingView(env, environmentKey);
                return;
            }

            const panoramaScene = new THREE.Scene();

            const sphereGeometry = new THREE.SphereGeometry(500, 64, 64);
            const textureLoader = new THREE.TextureLoader();

            textureLoader.load(env.image, (texture) => {
                const panoramaMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.BackSide
                });
                const panoramaMesh = new THREE.Mesh(sphereGeometry, panoramaMaterial);
                panoramaScene.add(panoramaMesh);
            }, undefined, (error) => {
                console.warn('Erro ao carregar panorama:', env.image, error);
            });

            const navPanel = document.createElement('div');
            navPanel.style.cssText = `
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0,0,0,0.7);
                padding: 15px;
                border-radius: 8px;
                z-index: 200;
                display: flex;
                gap: 10px;
            `;

            const backButton = document.createElement('button');
            backButton.textContent = '‚Üê Voltar ao Museu';
            backButton.style.cssText = `
                padding: 10px 20px;
                background: #1a73e8;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;
            backButton.onclick = () => exitPanoramaView();
            navPanel.appendChild(backButton);

            Object.keys(panoramaEnvironments).forEach(key => {
                if (key !== environmentKey) {
                    const btn = document.createElement('button');
                    btn.textContent = panoramaEnvironments[key].name;
                    btn.style.cssText = `
                        padding: 10px 15px;
                        background: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                    `;
                    btn.onclick = () => {
                        navPanel.remove();
                        createPanoramaScene(key);
                    };
                    navPanel.appendChild(btn);
                }
            });

            document.body.appendChild(navPanel);
            navPanel.id = 'panoramaNav';

            const instructions = document.createElement('div');
            instructions.innerHTML = `<strong>${env.name}</strong><br>Mova o mouse para olhar ao redor`;
            instructions.style.cssText = `
                position: absolute;
                top: 20px;
                left: 20px;
                color: white;
                background: rgba(0,0,0,0.7);
                padding: 15px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 200;
            `;
            document.body.appendChild(instructions);
            instructions.id = 'panoramaInstructions';

            currentPanoramaScene = panoramaScene;
            isPanoramaMode = true;

            renderer.domElement.style.display = 'none';

            const panoramaCamera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            panoramaCamera.position.set(env.position.x, env.position.y, env.position.z);

            const panoramaRenderer = new THREE.WebGLRenderer({ antialias: true });
            panoramaRenderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(panoramaRenderer.domElement);
            panoramaRenderer.id = 'panoramaRenderer';

            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            let rotX = 0, rotY = 0;

            panoramaRenderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            panoramaRenderer.domElement.addEventListener('mousemove', (e) => {
                if (mouseDown) {
                    const deltaX = (e.clientX - mouseX) * 0.005;
                    const deltaY = (e.clientY - mouseY) * 0.005;

                    rotY += deltaX;
                    rotX += deltaY;

                    rotX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotX));

                    panoramaCamera.rotation.order = 'YXZ';
                    panoramaCamera.rotation.y = rotY;
                    panoramaCamera.rotation.x = rotX;

                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            panoramaRenderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            panoramaRenderer.domElement.addEventListener('mouseleave', () => {
                mouseDown = false;
            });

            function animatePanorama() {
                if (!isPanoramaMode) return;
                requestAnimationFrame(animatePanorama);
                panoramaRenderer.render(panoramaScene, panoramaCamera);
            }
            animatePanorama();
        }

        function createEmbeddingView(env, environmentKey) {
            isPanoramaMode = true;
            renderer.domElement.style.display = 'none';

            const container = document.createElement('div');
            container.id = 'embeddingContainer';
            container.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                z-index: 199;
                display: flex;
                flex-direction: column;
            `;

            const title = document.createElement('div');
            title.style.cssText = `
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 15px;
                text-align: center;
                font-size: 20px;
                font-weight: bold;
                border-bottom: 2px solid #1a73e8;
            `;
            title.innerHTML = `<strong>${env.name}</strong>`;
            container.appendChild(title);

            const iframeContainer = document.createElement('div');
            iframeContainer.style.cssText = `
                flex: 1;
                display: flex;
                justify-content: center;
                align-items: center;
                padding: 10px;
                overflow: hidden;
            `;

            const iframe = document.createElement('iframe');
            iframe.src = env.embedUrl;
            iframe.style.cssText = `
                width: 95%;
                height: 95%;
                border: none;
                border-radius: 8px;
            `;
            iframe.setAttribute('allowfullscreen', '');
            iframe.setAttribute('loading', 'lazy');
            iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');
            iframeContainer.appendChild(iframe);
            container.appendChild(iframeContainer);

            const navBar = document.createElement('div');
            navBar.style.cssText = `
                background: rgba(0,0,0,0.8);
                padding: 15px;
                display: flex;
                gap: 10px;
                justify-content: center;
                flex-wrap: wrap;
                border-top: 2px solid #1a73e8;
            `;

            const backBtn = document.createElement('button');
            backBtn.textContent = '‚Üê Voltar ao Museu';
            backBtn.style.cssText = `
                padding: 12px 24px;
                background: #ff5252;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
            `;
            backBtn.onmouseover = () => backBtn.style.background = '#ff1744';
            backBtn.onmouseout = () => backBtn.style.background = '#ff5252';
            backBtn.onclick = () => exitEmbeddingView();
            navBar.appendChild(backBtn);

            Object.keys(panoramaEnvironments).forEach(key => {
                if (key !== environmentKey) {
                    const btn = document.createElement('button');
                    btn.textContent = panoramaEnvironments[key].name;
                    btn.style.cssText = `
                        padding: 10px 20px;
                        background: #4CAF50;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 13px;
                    `;
                    btn.onmouseover = () => btn.style.background = '#45a049';
                    btn.onmouseout = () => btn.style.background = '#4CAF50';
                    btn.onclick = () => {
                        container.remove();
                        createPanoramaScene(key);
                    };
                    navBar.appendChild(btn);
                }
            });

            container.appendChild(navBar);
            document.body.appendChild(container);
        }

        function exitEmbeddingView() {
            isPanoramaMode = false;
            const container = document.getElementById('embeddingContainer');
            if (container) container.remove();
            renderer.domElement.style.display = 'block';
            renderer.setAnimationLoop(animate);
        }

        function createDetailView() {
            detailScene = new THREE.Scene();

            // Criar Sky.js
            const sky = new THREE.Sky();
            sky.scale.setScalar(450000);
            detailScene.add(sky);

            // Configurar par√¢metros do c√©u
            const skyUniforms = sky.material.uniforms;
            skyUniforms['turbidity'].value = 2;
            skyUniforms['rayleigh'].value = 0.5;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            // Posi√ß√£o do sol (TARDE - sol elevado)
            const phi = THREE.MathUtils.degToRad(45);
            const theta = THREE.MathUtils.degToRad(180);
            const sunPosition = new THREE.Vector3();
            sunPosition.setFromSphericalCoords(1, phi, theta);
            skyUniforms['sunPosition'].value.copy(sunPosition);

            detailScene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            const detailFloor = new THREE.Mesh(floorGeometry, floorMaterial);
            detailFloor.rotation.x = -Math.PI / 2;
            detailFloor.receiveShadow = true;
            detailFloor.name = 'detailFloor';
            detailScene.add(detailFloor);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            ambientLight.name = 'detailAmbientLight';
            detailScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.name = 'detailDirectionalLight';
            detailScene.add(directionalLight);

            detailCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const detailCameraHolder = new THREE.Object3D();
            detailCameraHolder.position.set(0, 1.6, 5);
            detailCameraHolder.add(detailCamera);
            detailScene.add(detailCameraHolder);
            detailScene.detailCameraHolder = detailCameraHolder;

            detailRenderer = new THREE.WebGLRenderer({ antialias: true });
            detailRenderer.setSize(window.innerWidth, window.innerHeight);
            detailRenderer.setPixelRatio(window.devicePixelRatio);

            const backButton = document.createElement('button');
            backButton.innerHTML = '‚Üê Voltar ao Museu';
            backButton.style.cssText = `
                position: absolute;
                top: 20px;
                left: 20px;
                padding: 12px 24px;
                background: #ff5252;
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 16px;
                cursor: pointer;
                z-index: 200;
            `;
            backButton.onmouseover = () => backButton.style.background = '#ff1744';
            backButton.onmouseout = () => backButton.style.background = '#ff5252';
            backButton.onclick = () => exitDetailView();
            document.body.appendChild(backButton);
            backButton.id = 'backButton';
        }

        function enterDetailView(object) {
            isInDetailView = true;
            currentDetailObject = object;

            let styleId = document.getElementById('detailViewStyle');
            if (!styleId) {
                const style = document.createElement('style');
                style.id = 'detailViewStyle';
                style.textContent = `
                    .hotspot { display: none !important; pointer-events: none !important; }
                    .info-panel { display: none !important; pointer-events: none !important; }
                    #controls { display: none !important; }
                `;
                document.head.appendChild(style);
            }

            infoPanelOpen = false;

            if (!detailScene) {
                createDetailView();
            }

            renderer.domElement.style.display = 'none';
            document.body.appendChild(detailRenderer.domElement);
            detailRenderer.domElement.id = 'detailCanvas';

            const clonedObject = object.clone();
            clonedObject.position.set(0, 2.5, 0);
            clonedObject.scale.set(2, 2, 2);
            detailScene.add(clonedObject);

            animateDetailView();
        }

        function exitDetailView() {
            isInDetailView = false;

            const styleId = document.getElementById('detailViewStyle');
            if (styleId) styleId.remove();

            const detailCanvas = document.getElementById('detailCanvas');
            if (detailCanvas) detailCanvas.remove();

            renderer.domElement.style.display = 'block';

            const backButton = document.getElementById('backButton');
            if (backButton) backButton.remove();

            for (let i = detailScene.children.length - 1; i >= 0; i--) {
                const child = detailScene.children[i];
                if (child.name !== 'detailFloor' && !(child instanceof THREE.Light) && !child.children.includes(detailCamera)) {
                    detailScene.remove(child);
                }
            }

            updateHotspots();
            currentDetailObject = null;
            renderer.setAnimationLoop(animate);
        }

        function animateDetailView() {
            if (!isInDetailView) return;

            const deltaTime = 0.016;
            const detailCameraHolder = detailScene.detailCameraHolder;

            if (!detailCameraHolder) return;

            // ROTA√á√ÉO DA C√ÇMERA
            if (cameraRotationEnabled) {
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;

                detailCameraHolder.rotation.order = 'YXZ';
                detailCameraHolder.rotation.y = currentRotationY;
                detailCameraHolder.rotation.x = currentRotationX;
            }

            // MOVIMENTO - CORRIGIDO
            velocity.x -= velocity.x * 10.0 * deltaTime;
            velocity.z -= velocity.z * 10.0 * deltaTime;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const speed = isRunning ? 50.0 : 25.0;

            if (moveForward || moveBackward) velocity.z -= direction.z * speed * deltaTime;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * deltaTime;

            // Calcular movimento baseado na dire√ß√£o da c√¢mera
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            forward.set(
                Math.sin(currentRotationY),
                0,
                Math.cos(currentRotationY)
            );

            right.set(
                -Math.cos(currentRotationY),
                0,
                Math.sin(currentRotationY)
            );

            const moveAmount = new THREE.Vector3();
            moveAmount.addScaledVector(forward, velocity.z * deltaTime);
            moveAmount.addScaledVector(right, velocity.x * deltaTime);

            const newPosX = detailCameraHolder.position.x + moveAmount.x;
            const newPosZ = detailCameraHolder.position.z + moveAmount.z;

            const MAX_DISTANCE = 50;
            const distFromCenter = Math.hypot(newPosX, newPosZ);

            if (distFromCenter <= MAX_DISTANCE) {
                detailCameraHolder.position.x = newPosX;
                detailCameraHolder.position.z = newPosZ;
            }

            detailRenderer.render(detailScene, detailCamera);
            requestAnimationFrame(animateDetailView);
        }

        function init() {
            scene = new THREE.Scene();
            const textureLoader = new THREE.CubeTextureLoader();
            const skyboxTexture = textureLoader.load([
                './images/background 2.jpg',
                './images/background 2.jpg',
                './images/background 2.jpg',
                './images/background 2.jpg',
                './images/background 2.jpg',
                './images/background 2.jpg'
            ]);
            scene.background = skyboxTexture;
            scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            cameraHolder = new THREE.Object3D();
            cameraHolder.position.set(0, 1.6, 5);
            cameraHolder.add(camera);
            scene.add(cameraHolder);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x808080,
                roughness: 0.8,
                metalness: 0.2
            });
            floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            createMuseum();

            checkXRSupport();

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            window.addEventListener('resize', onWindowResize);

            try {
                x3 = new THREEx3({
                    THREE,
                    OrbitControls: THREE.OrbitControls,
                    camera,
                    renderer,
                    scene
                });
            } catch (error) {
                console.warn('x3 debugger n√£o dispon√≠vel:', error);
            }

            renderer.setAnimationLoop(animate);
        }

        function createMuseum() {
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });

            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(20, 5, 0.2),
                wallMaterial
            );
            backWall.position.set(0, 2.5, -10);
            scene.add(backWall);
            walls.push({
                min: new THREE.Vector3(-10, 0, -10.1),
                max: new THREE.Vector3(10, 5, -9.9)
            });

            const sideWall1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 5, 20),
                wallMaterial
            );
            sideWall1.position.set(-10, 2.5, 0);
            scene.add(sideWall1);
            walls.push({
                min: new THREE.Vector3(-10.1, 0, -10),
                max: new THREE.Vector3(-9.9, 5, 10)
            });

            const sideWall2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 5, 20),
                wallMaterial
            );
            sideWall2.position.set(10, 2.5, 0);
            scene.add(sideWall2);
            walls.push({
                min: new THREE.Vector3(9.9, 0, -10),
                max: new THREE.Vector3(10.1, 5, 10)
            });

            createPedestal(-5, 0, -5, 0xff6b6b, "Esta√ß√£o Espacial Internacional", "Uma representa√ß√£o detalhada da ISS, destacando sua arquitetura √∫nica e m√≥dulos cient√≠ficos.", "./models/ISS Correctglb.glb", 0.3);
            createPedestal(0, 0, -5, 0x4ecdc4, "Saturn V", "Um dos foguetes mais poderosos j√° constru√≠dos, simbolizando a explora√ß√£o espacial.", "./models/saturnVCorrect.glb", 0.2);
            createPedestal(5, 0, -5, 0xffe66d, "Ouro Solar", "Inspirada nos raios do sol, esta escultura captura luz e movimento em harmonia perfeita.", "./models/Voyager.glb");
            createPedestal(-5, 0, 0, 0x95e1d3, "Serenidade Verde", "Representa a natureza e crescimento. Observe os detalhes entrela√ßados.", "./models/jwst_james_webb_space_telescope.glb", 0.05);
            createPedestal(5, 0, 0, 0xf38181, "Rosa Eterno", "Uma homenagem ao amor e delicadeza. T√©cnica mista com elementos met√°licos.");

            createPainting(-8, 2, -9.8, 0xff6b6b);
            createPainting(-4, 2, -9.8, 0x4ecdc4);
            createPainting(0, 2, -9.8, 0xffe66d);
            createPainting(4, 2, -9.8, 0x95e1d3);
            createPainting(8, 2, -9.8, 0xf38181);

            createPanoramaPortal(-7, 0, 8, 'kennedy', 'üöÄ Kennedy Space Center');
            createPanoramaPortal(0, 0, 8, 'iss-lab', 'üõ∞Ô∏è ISS Laboratory');
            createPanoramaPortal(7, 0, 8, 'launch-pad', 'üî• Launch Pad');
        }

        function createPanoramaPortal(x, y, z, environmentKey, label) {
            const portalGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 32);
            const portalMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(x, y + 0.25, z);
            portal.userData = {
                interactive: true,
                isPortal: true,
                environmentKey: environmentKey,
                label: label
            };
            scene.add(portal);
            interactiveObjects.push(portal);

            obstacles.push({
                type: 'cylinder',
                x: x,
                z: z,
                radius: 1.2
            });
        }

        function createPedestal(x, y, z, color, title, description, modelPath = null, scale = 1) {
            const pedestalGeometry = new THREE.CylinderGeometry(0.5, 0.6, 1, 8);
            const pedestalMaterial = new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7
            });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(x, y + 0.5, z);
            scene.add(pedestal);

            obstacles.push({
                type: 'cylinder',
                x: x,
                z: z,
                radius: 0.7
            });

            if (modelPath) {
                gltfLoader.load(modelPath, (gltf) => {
                    const model = gltf.scene;
                    model.position.set(x, y + 1.5, z);
                    model.scale.set(scale, scale, scale);
                    model.userData = {
                        rotate: true,
                        interactive: true,
                        title: title,
                        description: description
                    };
                    scene.add(model);
                    interactiveObjects.push(model);
                }, undefined, (error) => {
                    console.error('Erro ao carregar modelo:', modelPath, error);
                    createDefaultObject(x, y, z, color, title, description);
                });
            } else {
                createDefaultObject(x, y, z, color, title, description);
            }
        }

        function createDefaultObject(x, y, z, color, title, description) {
            const objectGeometry = new THREE.TorusKnotGeometry(0.3, 0.1, 64, 8);
            const objectMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.3,
                metalness: 0.7
            });
            const object = new THREE.Mesh(objectGeometry, objectMaterial);
            object.position.set(x, y + 1.5, z);
            object.userData = {
                rotate: true,
                interactive: true,
                title: title,
                description: description
            };
            scene.add(object);
            interactiveObjects.push(object);
        }

        function createPainting(x, y, z, color) {
            const frameGeometry = new THREE.BoxGeometry(1.5, 2, 0.1);
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(x, y, z);
            scene.add(frame);

            const paintingGeometry = new THREE.PlaneGeometry(1.3, 1.8);
            const paintingMaterial = new THREE.MeshStandardMaterial({ color: color });
            const painting = new THREE.Mesh(paintingGeometry, paintingMaterial);
            painting.position.set(x, y, z + 0.06);
            scene.add(painting);
        }

        function checkXRSupport() {
            if ('xr' in navigator) {
                navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                    if (supported) {
                        const vrButton = document.getElementById('vrButton');
                        vrButton.style.display = 'block';
                        vrButton.addEventListener('click', onVRButtonClick);
                    }
                });
            }
        }

        function onVRButtonClick() {
            if (!renderer.xr.isPresenting) {
                navigator.xr.requestSession('immersive-vr', {
                    optionalFeatures: ['local-floor', 'bounded-floor']
                }).then(onSessionStarted);
            }
        }

        function onSessionStarted(session) {
            session.addEventListener('end', onSessionEnded);
            renderer.xr.setSession(session);
            document.getElementById('vrButton').textContent = 'Sair da RV';
        }

        function onSessionEnded() {
            document.getElementById('vrButton').textContent = 'Entrar em RV';
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    console.log('Direita pressionada');
                    moveRight = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = true;
                    isShiftPressed = true;
                    break;
                case 'Escape':
                    cameraRotationEnabled = !cameraRotationEnabled;
                    console.log('Rota√ß√£o da c√¢mera:', cameraRotationEnabled ? 'ativada' : 'desativada');
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isRunning = false;
                    isShiftPressed = false;
                    break;
            }
        }

        function onMouseMove(event) {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = (event.clientY / window.innerHeight) * 2 - 1;

            targetRotationY = -mouseX * Math.PI;
            targetRotationX = -mouseY * Math.PI * 0.25;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            const rotationSpeed = isShiftPressed ? rotationSpeedSlow : rotationSpeedNormal;

            if (cameraRotationEnabled && !infoPanelOpen) {
                currentRotationY += (targetRotationY - currentRotationY) * rotationSpeed;
                currentRotationX += (targetRotationX - currentRotationX) * rotationSpeed;
            }

            currentRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, currentRotationX));

            camera.rotation.order = 'YXZ';
            camera.rotation.y = currentRotationY;
            camera.rotation.x = currentRotationX;
            camera.rotation.z = 0;

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            const speed = isRunning ? 50.0 : 25.0;

            if (!infoPanelOpen) {
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;
            }

            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            forward.set(
                Math.sin(currentRotationY),
                0,
                Math.cos(currentRotationY)
            );

            right.set(
                -Math.cos(currentRotationY),
                0,
                Math.sin(currentRotationY)
            );

            const moveAmount = new THREE.Vector3();
            moveAmount.addScaledVector(forward, velocity.z * delta);
            moveAmount.addScaledVector(right, velocity.x * delta);

            const newPosX = cameraHolder.position.x + moveAmount.x;
            const newPosZ = cameraHolder.position.z + moveAmount.z;

            if (!checkCollision(newPosX, cameraHolder.position.z)) {
                cameraHolder.position.x = newPosX;
            } else {
                velocity.x = 0;
            }

            if (!checkCollision(cameraHolder.position.x, newPosZ)) {
                cameraHolder.position.z = newPosZ;
            } else {
                velocity.z = 0;
            }

            scene.traverse((child) => {
                if (child.userData.rotate) {
                    child.rotation.y += delta * 0.5;
                }
            });

            prevTime = time;

            x3.fps(() => {
                renderer.render(scene, camera);
            })

            updateHotspots();
        }

        function updateHotspots() {
            interactiveObjects.forEach(obj => {
                const distance = camera.position.distanceTo(obj.position);

                if (distance > 15) {
                    const hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);
                    if (hotspot) hotspot.style.display = 'none';

                    const panel = document.querySelector(`.info-panel[data-object="${obj.uuid}"]`);
                    if (panel) panel.remove();
                    return;
                }

                const vector = obj.position.clone();
                vector.project(camera);

                if (vector.z > 1) {
                    const hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);
                    if (hotspot) hotspot.style.display = 'none';

                    const panel = document.querySelector(`.info-panel[data-object="${obj.uuid}"]`);
                    if (panel) panel.remove();
                    return;
                }

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

                let hotspot = document.querySelector(`[data-object="${obj.uuid}"]`);

                if (!hotspot) {
                    hotspot = document.createElement('div');
                    hotspot.className = 'hotspot';
                    hotspot.innerHTML = 'i';
                    hotspot.dataset.object = obj.uuid;
                    hotspot.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const rect = hotspot.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        showInfoPanel(obj, centerX, centerY);
                    });
                    document.body.appendChild(hotspot);
                }

                hotspot.style.left = `${x - 20}px`;
                hotspot.style.top = `${y - 20}px`;
                hotspot.style.display = 'flex';
            });
        }

        function showInfoPanel(object, hotspotX, hotspotY) {
            if (object.userData.isPortal) {
                createPanoramaScene(object.userData.environmentKey);
                return;
            }

            document.querySelectorAll('.info-panel').forEach(p => p.remove());

            infoPanelOpen = true;

            const panel = document.createElement('div');
            panel.className = 'info-panel';
            panel.dataset.object = object.uuid;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-btn';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = function () {
                panel.remove();
                infoPanelOpen = false;
            };

            const title = document.createElement('h3');
            title.textContent = object.userData.title;

            const description = document.createElement('p');
            description.textContent = object.userData.description;

            const button = document.createElement('button');
            button.textContent = 'Ver em 3D';
            button.style.cssText = `
                margin-top: 10px;
                padding: 8px 16px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                width: 100%;
            `;
            button.onclick = () => {
                enterDetailView(object);
            };

            panel.appendChild(closeBtn);
            panel.appendChild(title);
            panel.appendChild(description);
            panel.appendChild(button);

            document.body.appendChild(panel);

            const panelWidth = panel.offsetWidth;
            const panelHeight = panel.offsetHeight;
            const padding = 15;

            let panelX = hotspotX + padding;
            let panelY = hotspotY - (panelHeight / 2);

            if (panelX + panelWidth > window.innerWidth - 10) {
                panelX = hotspotX - panelWidth - padding;
            }

            if (panelX < 10) {
                panelX = 10;
            }

            if (panelY < 10) {
                panelY = 10;
            }
            if (panelY + panelHeight > window.innerHeight - 10) {
                panelY = window.innerHeight - panelHeight - 10;
            }

            panel.style.left = `${panelX}px`;
            panel.style.top = `${panelY}px`;
        }

        function checkCollision(x, z) {
            for (let wall of walls) {
                const expandedMin = {
                    x: wall.min.x - playerRadius,
                    z: wall.min.z - playerRadius
                };
                const expandedMax = {
                    x: wall.max.x + playerRadius,
                    z: wall.max.z + playerRadius
                };

                if (x > expandedMin.x && x < expandedMax.x &&
                    z > expandedMin.z && z < expandedMax.z) {
                    return true;
                }
            }

            for (let obstacle of obstacles) {
                if (obstacle.type === 'cylinder') {
                    const dx = x - obstacle.x;
                    const dz = z - obstacle.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < obstacle.radius + playerRadius) {
                        return true;
                    }
                }
            }

            return false;
        }

        init();
    </script>
</body>

</html>